\documentclass{article}
\usepackage{iclr2021_conference,times}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,petri}
\usepackage{booktabs}
\usepackage{graphicx}
%\usepackage[square,numbers]{natbib}
\usepackage{makecell}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{subcaption}
\usepackage{bm}

\usepackage{textcomp}
\usepackage{amsthm}
\usepackage{amsmath}

\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}

\newcommand{\nt}[1]{{\bf [#1]}}
\newcommand{\R}{\mathbb{R}}


\title{CoLES: Contrastive Learning for Event Sequences with Self-Supervision}

\author{
Dmitrii Babaev \\
% dmitri.babaev@gmail.com
Sberbank AI Lab
\And
Nikita Ovsov \\
Sberbank AI Lab
\And
Ivan Kireev \\
Sberbank AI Lab
\And
Gleb Gusev \\
Sberbank AI Lab
\And
Maria Ivanova \\
Sberbank AI Lab
\And
Alexander Tuzhilin \\
% atuzhili@stern.nyu.edu
New York University
}

\begin{document}

\maketitle

\begin{abstract}

We address the problem of self-supervised learning on discrete event sequences generated by real-world users. Self-supervised learning incorporates complex information from the raw data in low-dimensional fixed-length vector representations that could be easily applied in various downstream machine learning tasks. In this paper, we propose a new method CoLES, which adopts contrastive learning, previously used for audio and computer vision domains, to the discrete event sequences domain in a self-supervised setting. Unlike most previous studies, we theoretically justify under mild conditions that the augmentation method underlying CoLES provides representative samples of discrete event sequences. We evaluated CoLES on several public datasets and showed that CoLES representations  
consistently outperform other methods on different downstream tasks.

\end{abstract}

\section{Introduction} \label{sec-intro}

%The size of the dataset is crucial for performance of modern supervised learning techniques~\citep{Sun2017RevisitingUE}. However, considering the rapid emergence of new applications and tasks in different domains, it is not possible to collect enough labeled data for many real world scenarios. This problem motivates extensive research~\citep{Tan2018ASO, Pan2010ASO} in the area of knowledge transfer where a model trained for one task can be further used as a good starting point for training in other tasks. 

A promising and rapidly growing approach known as self-supervised learning\footnote{See, e.g., keynote by Yann LeCun at ICLR-20: https://www.iclr.cc/virtual\_2020/speaker\_7.html} is the main choice for pre-training in situations where amount of labeled data for the target task of interest is limited. %The idea of self-supervised learning is to learn internal patterns of the input data based on a convenient synthetic task encouraging exploration without any additional information about "golden truth" output ~\citep{Peters2018DeepCW, Devlin2019BERTPO, Doersch2015UnsupervisedVR, Oord2018RepresentationLW}.
%Self-supervised learning is the main choice for pre-training in situations where the amount of labeled data for the target task of interest is very limited.
Most of research in the area of self-supervised learning has been focused on the core machine learning domains, including NLP (e.g., ELMO~\citep{Peters2018DeepCW}, BERT~\citep{Devlin2019BERTPO}), speech (e.g., CPC~\citep{Oord2018RepresentationLW}) and computer vision~\citep{Doersch2015UnsupervisedVR, Oord2018RepresentationLW}.
%There are also special self-supervised methods designed for continuous sequences, such as CPC~\citep{Oord2018RepresentationLW} for speech. 
%//most world corporate businesses (financial institutions, retail, ) generate sequential user data and //
However, there has been very little research on self-supervised learning in the domain of discrete event sequences, including  user behavior sequences~\citep{Ni2018PerceiveYU} such as credit card transactions at banks, phone calls and messages at telecom, purchase history at retail and click-stream data of online services. Produced in many business applications, such data is a major key to growth of modern companies. User behavior sequence is attributed to a person and captures regular and routine actions of certain type.
%, e.g., transactions, search queries, purchase history, phone calls and messages. 
The analysis of these sequences constitutes an  important sub-field of machine learning~\citep{Laxman2008StreamPU, Wiese2009CreditCT, Zhang2017CreditRA, Bigon2019PredictionIV}.


In this paper, we propose \emph{COntrastive Learning for Event Sequences (CoLES)} method that learns low-dimensional representations of discrete event sequences. It is based on a novel theoretically grounded data augmentation strategy, which adapts the ideas of contrastive learning~\citep{Xing2002DistanceML, Hadsell2006DimensionalityRB} to the discrete event sequences domain in a self-supervised setting.
%Most of existing contrastive learning methods have been successfully applied in core machine learning domains. 
The aim of contrastive learning is to represent semantically similar objects (\textit{positive pairs} of images, video, audio, etc.) closer to each other, while dissimilar ones (\textit{negative pairs}) further away. Positive pairs are obtained for training either {\it explicitly}, e.g., in a manual labeling process or {\it implicitly} using different data augmentation strategies (\cite{Falcon2020AFF}). We treat explicit cases as a {\it supervised} approach and implicit cases as a {\it self-supervised} one. In most applications, where each person is represented by one sequence of events, it is not reasonable to obtain manual labeling, thus only self-supervised approaches are applicable. Our CoLES method is self-supervised and based on the observation that event sequences usually possess periodicity and repeatability of its events. We propose and theoretically justify a new augmentation algorithm, which generates sub-sequences of an observed event sequence and uses them as different high-dimensional 
views of the same (sequence) object for contrastive learning.
% Глеб: здесь было окончание абзаца, которое потеряло актулаьность в связи с тем, что augmentation в CL - это не наше изобретение. Я его убрал. 
 %CoLES model trained in a self-supervised manner can be used in two ways.
Representations produced by the CoLES model can be used directly as a fixed vectors of features in some supervised downstream task (e. g. classification task) similarly to~\citep{Mikolov2013EfficientEO, Song2017LearningUE, Zhai2019LearningAU}. Alternatively, the trained CoLES model can be fine-tuned~\citep{Devlin2019BERTPO} for the specific downstream task.
We applied CoLES to several user behavior sequence datasets with different downstream classification tasks. When used directly as feature vectors, CoLES representations achieve strong performance comparable to the hand-crafted features produced by data scientists.
We demonstrate that fine-tuned CoLES representations consistently outperform methods based on other representations by a significant margin. %Moreover, we show superiority of CoLES embeddings over the supervised approach applied to the partially labeled raw data due to insufficient amount of the target to learn a sufficiently complex model from scratch.
We provide the full source code for all the experiments described in the paper\footnote{https://github.com/***/*** (the link was anonymized for the double-blind peer review purposes)}.

This paper makes the following contributions: (1) We present the CoLES method that adapts contrastive learning in the self-supervised setting to discrete event sequence domain. (2) We propose a novel theoretically grounded augmentation method for discrete event sequences. (3) We demonstrate that CoLES consistently outperforms previously introduced supervised, self--supervised and semi--supervised learning baselines adapted to the event sequence domain. We also conducted a pilot study on event sequence data 
%(clients card transactions and entities transfers) 
of a large European bank. We tested CoLES against the baselines and achieved superior performance on downstream tasks which produced significant financial gains. %for the bank.
% approaches both in supervised and the semi-supervised learning scenarios. %on four different user behavior sequence datasets.
%we also propose a new theoretically grounded data augmentation strategy our method significantly outperforms other approaches adapted to event sequences domain

The rest of the paper is organised as follows. In the next section, we discuss related studies on self-supervised and contrastive learning. In Section~\ref{sec-method} we introduce our new method CoLES for discrete event sequences. In Section~\ref{sec-exp} we demonstrate that CoLES outperforms several strong baselines including previously proposed contrastive learning methods adapted to event sequence datasets. Section~\ref{sec-conclusions} is dedicated to the discussion of our results and conclusions.

\section{Related work} \label{sec-rel-work}

Contrastive learning has been successfully applied to constructing low-dimensional representations (embeddings) of various objects, such as images~\citep{Chopra2005LearningAS, Schroff2015FaceNetAU}, texts~\citep{Reimers2019SentenceBERTSE}, and audio recordings~\citep{Wan2018GeneralizedEL}.
%, in a \textit{supervised} manner, where the same \textit{entity} can be represented by different \textit{samples}.
The aim of these studies is to identify the object based on its sample~\citep{Schroff2015FaceNetAU, Hu2014DiscriminativeDM, Wan2018GeneralizedEL}. Therefore, their training datasets explicitly contain several independent samples per each particular object, which form positive pairs as a critical component for learning. These supervised approaches are not applicable to our setting.

For situations when positive pairs are not available or their amount is limited, augmentation techniques were proposed in the computer vision domain. One of the first frameworks with augmentation  was proposed by \cite{Dosovitskiy2014DiscriminativeUF}. In this work, surrogate classes for model training were introduced using augmentations of the same image. Several recent works \citep{Bachman2019LearningRB, He2019MomentumCF, Chen2020ASF} extended this idea by applying contrastive learning methods, they are nicely summarised by \cite{Falcon2020AFF}. Although augmentation techniques proposed in these studies provide good performance empirically, we note that no theoretical background behind different augmentation approaches has been proposed so far.

Contrastive Predictive Coding (CPC) is a self-supervised learning approach proposed for non-discrete sequential data \citep{Oord2018RepresentationLW}. CPC extracts meaningful representations by predicting latent representations of future observations of the input sequence and using autoregressive methods. CPC representations demonstrated strong performance on four distinct domains: audio, computer vision, natural language and reinforcement learning. We adapted CPC based approach to the domain of discrete event sequences and compared it with our CoLES approach (see Section~\ref{sec-res}).

%One of the difficulties with applying a contrastive learning approach to the discrete event sequences is that the notion of semantic similarity as well as dissimilarity requires underlying domain knowledge and human labor-intensive labeling process to constrain positive and negative examples.

%In the computer vision domain, there are many other self-supervised approaches besides contrastive learning, they are nicely summarized in~\citep{Jing2020SelfsupervisedVF}. One of the common approaches to learn self-supervised representations is either traditional autoencoder~\citep{Rumelhart1986LearningIR} or variational autoencoder~\citep{Kingma2014AutoEncodingVB}. These methods are widely used for images, text and audio or aggregated event sequence data~\citep{Mancisidor2019LearningLR}. Although autoencoders have been successfully used in several domains listed above, they have not been applied to discrete event sequences, mainly due to the challenges of defining distances between the input and the output reconstructed sequences.

%There are papers dedicated to supervised learning for discrete event sequences~\citep{Wiese2009CreditCT, Tobback2019RetailCS, Babaev2019ETRNNAD, chatterjee2003modeling, sinha2014your}, but self-superivized pre-training is not used in those papers.

Independently of our study, several papers appeared in the past few months on self-supervision for user behaviour sequences in the recommender systems domain. \cite{Zhou2020ContrastiveLF} proposed to use CPC-like approach for self-supervised learning on user clicks history. \cite{Ma2020DisentangledSI} used an auxiliary self-supervised loss on click sequences. \cite{Zhou2020S3RecSL} proposed "Cloze" task from BERT \citep{Devlin2019BERTPO} for self-supervision on purchase sequences. Finally, \cite{Yao2020SelfsupervisedLF} adapts SimCLR-like approach for text-based tasks and tabular data. Although there has been significant progress on contrastive learning, augmentation for contrastive learning does not have any theoretical grounding and is understudied in the domain of discrete event sequences.

%We briefly review its general idea. Assume that each entity $e$ is associated with a probabilistic distribution $P_e$ over all possible samples (e.g., in face recognition, a person is a distribution over all his/her photos that can potentially appear in the life). The idea is to train encoder $M$ such that samples of the same or similar entities represented in the feature space are closer to each other than samples of different (dissimilar) entities. Mapping $M$ defines a pushforward $P_M(e):=M\#P_e$ of distribution $P_e$ in the feature space $\R^d$ for each entity $e$. In these terms, contrastive learning tends to separate distributions $P_M(e)$ of different entities $e$ as much as possible.

\section{Problem formulation and overview of the CoLES method} \label{sec-method}

\subsection{Problem formulation} \label{sec:problem setting}

While the method proposed in this paper could be studied in different domains, in this paper we focus on discrete sequences of events. Assume there are some entities $e$, and the life activity of each entity~$e$ is observed as a sequence of events $x_e:=\{x_e(t)\}^{T_e}_{t=1}$. Entities could be people or organizations or some other abstractions. Events $x_e(t)$ may have any nature and structure (e.g., transactions of a client, click logs of a user), and their components may contain numerical, categorical, and textual fields (see datasets description in Section~\ref{sec-exp}). 
% $\{x_e(t)\}^{T_e}_{t=1}$.

According to theoretical framework of contrastive learning proposed in~\cite{Saunshi2019ICML}, each entity $e$ is a latent class, which is associated with a distribution $P_e$ over its possible samples (event sequences). However, unlike the problem setting of  \cite{Saunshi2019ICML}, we have no positive pairs, i.e. pairs of event sequences representing the same entity $e$. Instead, we have only one sequence $x_e$ per entity~$e$. Formally, each entity $e$ is associated with a latent stochastic process $\{X_e(t)\}_{t=1}^{T_e}$, and we observe {\it only one} realisation $\{x_e(t)\}_{t=1}^{T_e}$ generated by the process $\{X_e(t)\}$. Our goal is to learn an \textit{encoder} $M$ that maps event sequences into a feature space~$\R^d$ in such a way that the obtained \textit{embedding} $c_e=M(\{x_e\})\in \R^d$ of sequence $\{x_e(t)\}^{T_e}_{t=1}$ encodes essential properties of~$e$ and disregards any randomness and noise contained in the sequence. That is, embeddings $M(\{x_1\})$ and $M(\{x_2\})$ should be close to each other, if $x_1$ and $x_2$ are sequences generated by the same process $\{X_e(t)\}$, and they should be further away, when generated by distinct processes. The quality of representations can be examined by downstream tasks related to the properties of entity $e$. %(see Section~\ref{sec-res}). 
%as follows: (1) $c_e$ can be used as a feature vector for a task--specific model, and (2) encoder $M$ can also be (jointly) fine-tuned~\citep{Yosinski2014HowTA}.

\subsection{Sampling of surrogate sequences as an augmentation procedure} \label{sec-pos-pairs}

While we have no access to the latent processes $\{X_e(t)\}$, we need to use augmentation. Most augmentation techniques proposed earlier for continuous domains (such as image jitter, color jitter or random gray scale in computer vision, see \cite{Falcon2020AFF}) are not applicable to discrete events. A possible approach for augmentation is generating
{\it sub-sequences} of the same event sequence $\{x_e(t)\}$. The idea proposed below resembles the bootstrap method~\citep{Efron1994Bootstrap}, which enables to generate several bootstrap samples using only one sample of independent datapoints of a latent distribution. However, our setting is different, since we have no independent observations, so we should rely on different data assumptions. 
The key property of event sequences that represent life activity is periodicity and repeatability of its events. This is a motivation for the \textit{Random slices} sampling method applied in CoLES, as presented in Algorithm~\ref{alg-slce-ss}. Each sub-sequence is generated from the initial sequence as its connected segment ("slice") using the following three steps. First, the length of the slice is chosen uniformly from possible values. Second, its starting position is uniformly chosen from all possible values. Third, too short (and optionally too long) sub-sequences are discarded. It could seem that the mean length of obtained sub-sequences are less than the mean length of sequences in the dataset. However, we show in the next section that the distribution of sub-sequences is close to the initial distribution in some realistic assumptions. The overview of the CoLES method is presented in Figure \ref{fig-arch}.


\begin{figure}[htbp]
  \includegraphics[width=\linewidth]{figures/CoLES-arch.pdf}
\caption{General framework}
  \label{fig-arch}
\end{figure}



\begin{algorithm}
\SetAlgoLined
\textbf{hyperparameters:} $m, M$: minimal and maximal possible length of a sub-sequence\\ $k$: number of trials.\\ %sub-sequences to be produced. \\
\textbf{input:} A sequence $S$ of length $T$. \\
\textbf{output:} $\mathcal{S}$: sub-sequences of $S$. \\

\BlankLine
 \For{$i\leftarrow 1$ \KwTo $k$}{
 Generate random integer $T_i$ uniformly from $[1,T];$\\
 \uIf{$T_i\in [m, M]$}
 {
  Generate random integer $s$ from $[0, T-T_i-1]$;\\
  Add $S_i := S[s: s + T_i-1]$ to $\mathcal{S}$
 }
}
\caption{Random slices sub-sequence generation strategy}
\label{alg-slce-ss}
\end{algorithm}

\subsection{Theoretical analysis} \label{sec-theory}

Assume that process $\{X_e(t)\}_{t=1}^{T_e}$ is a segment of a latent process $\{\widehat{X}_e(t)\}_{t=1}^{\infty}$, which generates sequence of all events in the potentially infinite life of entity $e$. That is, we assume that $X_e(t)=\widehat{X}_e(t+s_e)$ for some random starting point $s_e\in \{0,1,\ldots\}$ and horizon $T_e$. Thus we observe, in our data, segment $[s_e+1,s_e+T_e]$ of the life of $e$. We also make the following Assumptions:
\begin{enumerate}
    \item Process $\{\widehat{X}_e(t)\}_{t=1}^{\infty}$ is cyclostationary (in the strict sense)~\citep{Gardner2006Cyclostationarity} with some period $\widehat{T}$.
    \item Starting $s_e$ is independent, and the distribution of $(s_e \mod \widehat{T})$ is uniform over $[0,\widehat{T}-1]$.
    \item Horizon $T_e$ is independent and follows a power--law distribution on $[m,\infty]$.
\end{enumerate}
These assumptions correspond to a scenario where some persons become clients of a service at a random moment and for some random time span and their behaviour obey some periodicity.    %First assumption is $\ldots$ 
\begin{thm}\label{thm:distribution}
If sequences $\{x_e(t)\}$ in the dataset are generated from latent processes $\{\widehat{X}_e(t)\}$ as described above, then sub-sequences obtained by Algorithm~\ref{alg-slce-ss} from $\{x_e(t)\}$ follow the same distribution as $\{x_e(t)\}$ up to a slight alteration of the distribution of the horizon $T_e$. Namely, if $T_e$ follows power law with an exponent $\alpha <-1$, then the density function for the length $T'_e$ of a sub-sequence satisfy $p(T'_e=k)/p(T_e=k)\in [(\frac{m-1}{m})^{-\alpha},(\frac{k}{k-1/2})^{-\alpha}]$.
\end{thm}
This theorem means that a sub-sequence obtained by Algorithm~\ref{alg-slce-ss} is a representative sample of entity~$e$ and follows its latent distribution $P_e$. Combining this result with generalization guarantees proved for setting with explicitly observed positive pairs~(\cite{Saunshi2019ICML}), we obtain theoretical background for our implicit self-supervised setting.   
%Further in this paper, we empirically examine whether pairs of such sub-sequences are useful for contrastive learning-based self-supervision.
See Appendix~\ref{app-sec-proof} for the proof of Theorem~\ref{thm:distribution}.

\subsection{Model training} \label{sec-training}

\textbf{Batch generation.} The following procedure creates a batch during CoLES training. $N$ initial sequences are randomly taken and $K$ sub-sequences are produced for each of them. Pairs of sub-sequences of the same sequence are used as positive samples and pairs from different sequences are used as negative ones.
%Hence, after positive pair generation, each batch contains %$N \times K$ sub-sequences used as training samples. There are $NK(K-1)/2$ positive pairs and can potentially have $K^2N(N - 1)/2$ negative pairs (not all negative pairs are considered, due to negative sampling).

We consider several baseline empirical strategies for sub-sequence generation to compare with Algorithm~\ref{alg-slce-ss}. The simplest strategy is the random sampling without replacement.
One more strategy is to produce sub-sequences by random splitting of the initial sequence to several connected segments without intersection between them
%To generate k sub-sequences, the following procedure should be repeated k times: take a random number of elements from the sequence \textit{without replacement}
(see Appendix~\ref{app-sec-bg}). %The motivation is that intersections between sub-sequences may possibly lead to overfilling, since exact sub-sequences of events are the same and may be "remembered" without learning a deeper level of similarities.

% Note, that the order of events in generated sub-sequences is always preserved.


%\subsection{Contrastive learning losses} \label{sec-ml-loss}

% We consider several contrastive learning losses that showed promising performance on different datasets~\citep{Kaya2019DeepML} and some classical variants: contrastive~loss~\citep{Hadsell2006DimensionalityRB}, binomial deviance loss~\citep{Yi2014DeepML}, triplet loss \citep{Hoffer2015DeepML}, histogram~loss~\citep{Ustinova2016LearningDE}, and margin~loss~\citep{Manmatha2017SamplingMI}. Among them, contrastive loss showed best performance in experiments (see Appendix~\ref{app-sec-design}).

\textbf{Contrastive loss} We consider a classical variant of the contrastive loss, proposed by \citep{Hadsell2006DimensionalityRB}: %has a contrastive term for negative pairs of embeddings, which penalizes the model only if the distance between embeddings of negative pair is less than a margin $m>0$:
$ \mathcal{L} =  (1-Y)\frac{1}{2}(D_W^i)^2 +Y*\frac{1}{2}\{max(0,m-D_W^i)\}^2 $, where $D_W^i$ is a distance function between embeddings in i-th labeled sample pair, $Y$ is a binary variable identifying that the pair is positive.
As proposed in~\citep{Hadsell2006DimensionalityRB}, we use euclidean distance function: $D_W^i = D(A,B) = \sqrt{\sum_i(A_i - B_i)^2}$.

\textbf{Pair distance calculation.} In order to select negative samples, we need to compute pairwise distance between all possible pairs of embedding vectors of a batch. For the purpose of making this procedure more computationally effective we perform normalization of the embedding vectors, i.e. project them on a hyper-sphere of unit radius (see Appendix~\ref{app-sec-perf-opt}).


\textbf{Negative sampling} is a way to address the following challenge of the contrastive learning approach: using all pairs of samples can be inefficient: for example, some of the negative pairs are already distant enough, thus these pairs are not valuable for the training~\citep{SimoSerra2015DiscriminativeLO, Schroff2015FaceNetAU}. Hence, only a part of possible negative pairs in the batch are used during loss calculation. We compared most popular choices for negative sampling applied for CoLES, see Section~\ref{sec-res} for details.

\subsection{Encoder architecture} \label{sec-enc-arch}

To embed a sequence of events to the fixed-size vector, we use an encoder network, which consists of two conceptual parts: the event encoder and the sequence encoder subnetworks.

\textbf{The event encoder} $e$ takes the set of attributes of each single event $x_t$ and outputs its representation in the latent space $\R^d$: $z_t = e(x_t)$. The event encoder consists of several embedding layers and batch normalization layers. Each categorical attribute is encoded by its corresponding embedding layer. Batch normalization is applied to numerical attributes of events. Outputs of all embedding and batch normalization layers are concatenated to produce latent representation $z_t$.

\textbf{The sequence encoder} $s$ takes latent representations of the sequence of events: $ z_{1:T} = z_1, z_2, \cdots z_T $ and outputs the representation of the whole sequence $c_t$ in the time-step $t$: $ c_t = s(z_{1:t}) $.
Several approaches can be used to encode a sequence~\citep{Cho2014LearningPR, Vaswani2017AttentionIA} . In our experiments we use the recurrent network (RNN) similarly to~\citep{Sutskever2014SequenceTS}. The output produced for the last event is used to represent the whole sequence of events. In case of RNN the last output $h_t$ is a representation of the sequence.

To summarise, CoLES method consists of three major ingredients: event sequence encoder, positive and negative pair generation strategy and the loss function for contrastive learning.

%In the next section, we describe our experiments of the comparison of the proposed method with several strong baselines on several public datasets.

\section{Experiments} \label{sec-exp}

We compare our method with existing baselines on several publicly available datasets from various data science competitions. We chose datasets with sufficient amounts of discrete events per user.

\textbf{Age group prediction competition}\footnote{https://ods.ai/competitions/sberbank-sirius-lesson}. The dataset of 44M anonymized credit card transactions representing 50k persons was used to predict the age group of a person. The label is known for 30k persons, other 20k are unlabelled. The group ratio is balanced in the dataset. Each transaction includes date, type, and the amount being charged.

%\textbf{Gender prediction competition}\footnote{https://www.kaggle.com/c/python-and-analyze-data-final-project/}. The dataset of 6,8M anonymized card transactions representing 15K clients was used to predict a gender. Each transaction is characterized by date, type, amount and Merchant Category Code.

\textbf{Churn prediction competition}\footnote{https://boosters.pro/championship/rosbank1/}. The dataset of 1M anonymized card transactions representing 10K clients was used to predict a churn probability. Each transaction is characterized by date, type, amount and Merchant Category Code. 5k clients have labels, 5.2k clients haven't labels. Target is binary, almost balanced with proportions 0.55 and 0.45.

\textbf{Assessment prediction competition}\footnote{https://www.kaggle.com/c/data-science-bowl-2019}. The task is to predict the in-game assessment results based on the history of children gameplay data. Target is one of 4 grades, with proportions 0.50, 0.24, 0.14, 0.12. The dataset consists of 12M gameplay events representing 18k children. Gameplays of the nearly all (17.7k) children are labelled, the gameplays of the remaining 312k children are not labelled. Each gameplay event is characterized by timestamp, event code, incremental counter of events within a game session, time since the start of the game session, etc.

\textbf{Retail purchase history age group prediction}\footnote{https://ods.ai/competitions/x5-retailhero-uplift-modeling}. The task is to predict the age group of a client based on its retail purchase history. The group ratio is balanced in the dataset. Only labeled data is used. The dataset consists of 45,8M retail purchases representing 400k clients. Each purchase is characterized by time, product level, segment, amount, value, loyalty program points received.

As we can see in Figure~\ref{fig-seq-len} (Appendix~\ref{app-sec-datasets}), these datasets satisfy the power law assumption for the sequence length distribution of Theorem~\ref{thm:distribution}.

%\textbf{Experimental setup.}

\textbf{Dataset split.} For each dataset, we set apart 10\% persons from the labeled part of the data as the \textit{test set} that we used for evaluation of different models. The rest 90\% of labeled data and unlabeled data constitute our \textit{training set} used for learning. For all methods, random search on 5-fold cross-validation over the training set is used for hyper-parameter selection. The hyper-parameters with the best out-of-fold performance are then chosen.
For learning of semi-supervised/self-supervised techniques (including CoLES), we used all transactions of training sets including unlabeled data. The unlabelled parts of the datasets were ignored while training supervised models.

\textbf{Performance.} Neural network training was performed on a single Tesla P-100 GPU card. For the training part of CoLES, the single training batch is processed in 142 milliseconds. For example, in the age group prediction dataset the single training batch contains 64 unique persons with 5 sub-sequences per person, i.e. 320 training sub-sequences in total, the mean number of transactions in a sub-sequence is 90, hence each batch contains about 28800 transactions.

\textbf{Hyperparameters} Unless we explicitly specify, we use contrastive loss and random slices pair generation strategy for CoLES in our experiments (see Section~\ref{sec-res} for motivation). The final set of hyper-parameters used for CoLES is shown in the Appendix~\ref{app-sec-exp-setup}, Table \ref{tab-hyper}.

\subsection{Baselines} \label{sec-baselines}

%We compare our CoLES method with the following baselines.

\textbf{LightGBM.} We consider the Gradient Boosting Machine (GBM) method~\citep{Friedman2001GreedyFA} on hand-crafted features. GBM can be considered as a strong baseline in cases of tabular data with heterogeneous features.
% In particular, GBM-based approaches achieve the state-of-the-art results in a variety of practical tasks including web searches, weather forecasting, fraud detection, and many others
~\citep{Wu2009AdaptingBF, Vorobev2019LearningTS, Zhang2015AGB, Niu2019ACS}.
GBM based model requires a large number of hand-crafted aggregate features produced from the raw transactional data. An example of an aggregate feature is an average spending amount in some category of merchants, such as hotels of the entire transaction history.
We used LightGBM~\citep{Ke2017LightGBMAH} implementation of the GBM algorithm with nearly 1,000 hand-crafted features for the application. The details of producing hand-crafted features can be found in the Appendix~\ref{app-sec-hand}.

\textbf{Self-supervised baselines.} 

\textbf{NSP.} We consider a simple baseline inspired by the \textit{next sentence prediction} task used in BERT~\citep{Devlin2019BERTPO}. Specifically, we generate two sub-sequences A and B, in a way that 50\% of the time B is the sub-sequence from the same sequence as A and follows it (positive pair), and 50\% of the time it is a random sub-sequence taken from other sequence (negative pair).

\textbf{SOP.} Another simple baseline is the same as \textit{sequence order prediction} task from ALBERT~\citep{Lan2020ALBERTAL}. It uses two consecutive sub-sequences as a positive pair, and two consecutive sub-sequences with swapped order as a negative pair.

\textbf{RTD.} We also adapt the \textit{replaced token detection} approach from ELECTRA~\citep{Clark2020ELECTRAPT} for event sequences as a baseline for our research. We replaced 15\% of events from sequence with random events, taken from other sequences and train a model to predict whether an event is replaced or not.

\textbf{CPC.} As the last self-supervised baseline, we selected the recently proposed Contrastive Predictive Coding (CPC)~\citep{Oord2018RepresentationLW}, a self-supervised learning method that produced excellent performance on sequential data of such traditional domains as audio, computer vision, reinforcement learning and recommender systems~\citep{Zhou2020ContrastiveLF}.
% We adapted the CPC method to the discrete event sequences by making the model task to distinguish true future events from other types of events by using series of previous events as an input.

\textbf{Supervised learning}. In addition to the aforementioned baselines, we compare our method with a supervised learning approach where the encoder network $e$ (see Section~\ref{sec-enc-arch}) and the classification sub-network $h$ are jointly trained on the downstream task target, i. e. the classification sub-network takes encoder output and produces a prediction: $\hat{y} = h(e(x))$. One-layer neural net with softmax activation is used as $h$. Note that no pre-training is used in this case.

Note that all neural network baselines use the same architecture of the encoder model as CoLES.


\subsection{Results} \label{sec-res}

\begin{table}
\centering
\caption{Comparison of batch generation strategies}
\begin{tabular}{llll}
\toprule
\textbf{Dataset} & \textbf{Random samples} & \textbf{Random disjoint samples} & \textbf{Random slices} \\
\midrule
\makecell{\textbf{Age group} \small{(Accuracy)}} & $0.613 \pm 0.006$ & $0.619 \pm 0.011$ & \textbf{0.639} $\pm 0.006$ \\
% \makecell{\textbf{Gender} \small{(AUROC)}} & $0.860 \pm 0.016$ & $0.848 \pm 0.018$ & \textbf{0.876} $\pm 0.007$ \\
\makecell{\textbf{Churn} \small{(AUROC)}} & $0.820 \pm 0.014$ & $0.819 \pm 0.011$ & \textbf{0.823} $\pm 0.017$ \\
\makecell{\textbf{Assessment} \small{(Accuracy)}} & $0.563 \pm 0.004$ & $0.563 \pm 0.004$ & \textbf{0.618} $\pm 0.009$ \\
\makecell{\textbf{Retail} \small{(Accuracy)}} & $0.523 \pm 0.001$ & $0.505 \pm 0.002$ & \textbf{0.542} $\pm 0.002$ \\
\bottomrule
\end{tabular} \\
\small{5-fold cross-validation metric $\pm 95\%$ is shown}
\label{tab-pair-gen}
\end{table}

\textbf{Features of CoLES.} To evaluate the proposed method of sub-sequence generation we compared it with two alternative strategies described in Section~\ref{sec-training}. The results are presented in Table~\ref{tab-pair-gen}. The proposed random slices sub-sequence generation strategy significantly outperforms alternative strategies, what confirm theoretical results (see Section \ref{sec-theory}). Also, note that random samples strategy is similar to the augmentation strategy proposed by \cite{Yao2020SelfsupervisedLF}, and random disjoint samples strategy is similar to sub-sequence generation proposed by \cite{Ma2020DisentangledSI}.

We evaluated several possible loss functions and found that contrastive loss that can be considered as the basic variant of contrastive learning loss, performs on par or better than other losses on the downstream tasks (see Appendix~\ref{app-sec-design}, Table~\ref{tab-loss-type}). This means that improvements obtained by more recent losses in object recognition tasks does not necessarily lead to gains in other downstream tasks.
%an increase in model performance on the contrastive learning task, measured as quality of the object recognition task, which is usually the case for more advanced losses does not necessarily lead to the performance increase on downstream tasks.

We also compared popular negative sampling strategies (distance-weighted sampling~\citep{Manmatha2017SamplingMI}, and hard-negative mining~\citep{Schroff2015FaceNetAU}) with random negative sampling strategy. The results are shown in the Appendix~\ref{app-sec-design}, Table \ref{tab-neg-sampl}. We found that hard negative mining leads to significant increase in quality on downstream tasks in comparison to random negative sampling.

\begin{figure}
  \centering
  \begin{subfigure}[t]{0.49\linewidth}
    \caption{Age group}
    \includegraphics[width=\linewidth]{figures/ss_age_pred_per.pdf}
    \label{fig-semi-age}
  \end{subfigure}
  \hfill%
  \begin{subfigure}[t]{0.49\linewidth}
    \caption{Assessment}
    \includegraphics[width=\linewidth]{figures/ss_bowl2019_per.pdf}
    \label{fig-semi-assessment}
  \end{subfigure}%
  \caption{Model quality for different dataset sizes}
    \small{The rightmost point corresponds to all labels and supervised setup.}
  \label{fig-semi-main}
\end{figure}

\textbf{Comparison with baselines.} We compared CoLES with baselines described in Section~\ref{sec-baselines} in two scenarios. First, we compared embeddings produced by CoLES encoder with other types of embeddings and with manually created aggregates by using them as input features of a downstream task model. The downstream task model is trained by LightGBM~\citep{Ke2017LightGBMAH}  independently from the sequence encoder. As Table~\ref{tab-downstream-res} demonstrates, our method generates sequence embeddings of sequential data that achieve strong performance results in comparison to the case of manually crafted features when used on the downstream tasks.
In particular, Table~\ref{tab-downstream-res} shows that even unsupervised CoLES embeddings perform on par and sometimes even better than hand-crafted features. Also note, that CoLES embeddings outperform embeddings produced by the other self-supervised baselines on each dataset.

In the second scenario, we fine-tune pre-trained models for specific downstream tasks. The models are pre-trained using CoLES and other self-supervised learning approaches and then are additionally trained on the labelled data for the specific task in the same way as we trained a neural net for the supervised learning (see Section~\ref{sec-baselines}). A neural net without pre-training is also added to the comparison. As Table~\ref{tab-downstream-res} shows, fine-tuned representations obtained by our method achieve superior performance on all the considered datasets, outperforming all other methods by statistically significant margins.

\begin{table}
\centering
\caption{Accuracy on the downstream tasks: Metric increase against baseline}
\begin{tabular}{llllll}
\toprule
\textbf{Method} & \makecell{\textbf{Age group} \\ \small{Accuracy}} & \iffalse \makecell{\textbf{Gender} \\ \small{AUROC}} \fi & \makecell{\textbf{Churn} \\ \small{AUROC}} & \makecell{\textbf{Assessment} \\ \small{Accuracy}} & \makecell{\textbf{Retail} \\ \small{Accuracy}}\\
\midrule
\textbf{LightGBM:} \\
\makecell[r]{\textbf{Designed features}} & $0.631 \pm 0.004$ & \iffalse $0.875 \pm 0.003$ \fi & $0.825 \pm 0.005$ & $0.602 \pm 0.006$ & $0.547 \pm 0.001$ \\

\makecell[r]{\textbf{SOP embeddings}} & $-21.9\% \pm  0.6\%$ & \iffalse $-14.4\% \pm  1.1\%$ \fi & $-5.3\% \pm  0.8\%$ & $-4.1\% \pm  1.0\%$ & $-22.8\% \pm  0.2\%$\\
\makecell[r]{\textbf{NSP embeddings}} & $-1.5\% \pm  0.9\%$ & \iffalse $-4.4\% \pm  0.5\%$ \fi & $+0.6\% \pm  0.7\%$ & $-3.5\% \pm  1.1\%$ & $-22.3\% \pm  0.4\%$\\
\makecell[r]{\textbf{RTD embeddings}} & $+0.1\% \pm  0.6\%$ & \iffalse $-1.7\% \pm  0.5\%$ \fi & $-2.9\% \pm  0.8\%$ & $-3.6\% \pm  1.1\%$ & $-5.0\% \pm  0.3\%$\\

\makecell[r]{\textbf{CPC embeddings}} & $-5.9\% \pm  0.6\%$ & \iffalse $-3.5\% \pm  0.4\%$ \fi & $-2.9\% \pm  0.6\%$ & $-2.3\% \pm  0.9\%$ & $-4.0\% \pm  0.3\%$\\
\makecell[r]{\textbf{\hspace{0.02\textwidth} CoLES embeddings}} & $+1.1\% \pm  1.2\%$ & \iffalse $1.7\% \pm 0.5\%$ \fi &  \bm{$+2.2\%$} $\pm  0.6\%$ & $-0.1\% \pm  0.9\%$ & $-1.4\% \pm 0.2\%$ \\
\midrule
\textbf{Supervised learning} & $0.628 \pm  0.005$ & \iffalse $0.856 \pm  0.008$ \fi &  $0.817 \pm  0.012$ & $0.602 \pm  0.006$  & $0.542 \pm  0.001$\\

\textbf{RTD fine-tuning} & $+1.2\% \pm  1.2\%$ & \iffalse $+3.0\% \pm  1.2\%$ \fi &  $+0.3\% \pm  1.3\%$ & $-2.7\% \pm  1.0\%$ & $+0.5\% \pm  0.4\%$ \\

\textbf{CPC fine-tuning} & $-2.1\% \pm  1.6\%$ & \iffalse $+1.9\% \pm  0.8\%$ \fi &  $-0.9\% \pm  1.4\%$ & $+0.7\% \pm  1.1\%$ & $+1.2\% \pm  0.3\%$ \\
\textbf{CoLES fine-tuning} & \bm{$+2.5\%$} $\pm  1.0\%$ & \iffalse \bm{$+4.0\%$} $\pm  0.9\%$ \fi &  \bm{$+1.1$}\% $\pm  1.3\%$ & \bm{$+2.2\%$} $\pm  1.1\%$ & \bm{$+1.9\%$} $\pm  0.2\%$ \\
\bottomrule
\end{tabular} \\
\small{test set quality metric $\pm 95\%$ is shown}
\label{tab-downstream-res}
\end{table}

\textbf{Semi-supervised setup.} To evaluate our method in case of the restricted amount of labeled data, we performed the series of experiments where only a fraction of available labels are used to train the downstream task model.
As in the case of the supervised setup, we compare the proposed method with LigthGBM over hand-crafted features, CPC, and supervised learning without pre-training (see Section \ref{sec-baselines}).

The results of this comparison are presented in Figure \ref{fig-semi-main}.
Note that the difference in performance between CoLES and supervised-only methods increases as we decrease the number of available labels. Also note that CoLES consistently outperforms CPC for different volumes of labeled data.

\textbf{Business applications.} In addition to the described experiments on public datasets, we have performed extensive testing of our method on the private data in large European bank. We've observed a significant increase in model performance (+ 2-10\% AUROC) after addition of CoLES embeddings to the existing models in many downstream tasks, including credit scoring, marketing campaign targeting, product recommendations cold start, fraud detection and legal entities connections prediction.


\section{Conclusions} \label{sec-conclusions}

In this paper, we present \emph{Contrastive Learning for Event Sequences (CoLES)}, a novel self-supervised method for building embeddings of discrete event sequences.
In particular, the CoLES method can be effectively used for pre-training neural networks in semi-supervised settings. It can also be used to produce embeddings of complex event sequences that can be effectively used in various downstream tasks.

We also empirically demonstrate that our approach achieves strong performance results on several downstream tasks and significantly outperforms both classical machine learning baselines on hand-crafted features, as well as other  previously introduced  self--supervised and semi--supervised learning baselines adapted to the event sequence domain.
In the semi-supervised setting, where the number of labelled data is limited, our method demonstrates even stronger results: the lesser is the labelled data the larger is performance margin between CoLES and supervised-only methods.
% The proposed method of generating embeddings is convenient for production usage since the pre-calculated embeddings can be easily used for different downstream tasks without performing complex and time-consuming computations on the raw event data.
% For some encoder architectures, it is even possible to incrementally update the already calculated embeddings when new data arrives, as is shown in Section \ref{app-sec-perf-opt}.

The method is especially adapted for event sequence data which is extensively used by the core businesses of many large companies, including financial institutions, internet companies, retail and telecom.
%We also conducted a pilot study on a private event sequence data of a large European bank and CoLES embeddings achieved superior performance on downstream classification tasks which produced significant financial gains for the bank.

% \section*{Broader Impact}

% This paper focused on developing a general novel contrastive learning method for the task of self-supervised learning for the discrete event sequences. Therefore, it can be applied to a broad range of practical applications, many of them having strong social and business impacts, such as educational applications dealing with logs of educational activities of  students, security applications dealing with logs of internet access activities and system logs protecting users from various types of malicious cyber-attacks, logs of online games, retail purchase histories, bank transactions and various other types of sequences. 

% Furthermore, our method has strong fairness mechanisms built into it since it focuses on the analysis of the granular event sequences and, therefore, does not have to deal with the problem of biased decisions and predictions stemming from poorly computed aggregate data leading to various types of social biases.

% Another advantage of using event sequence based embeddings, instead of the raw explicit event data, is that it is exceptionally difficult to restore the exact input sequence from its embeddings due to the fact, that lots of information is dropped during the transformation to embeddings. Therefore, the usage of embeddings leads to better privacy and data security for the end users than when working directly with the raw event data, and all this is achieved without sacrificing valuable information for downstream tasks.



\bibliographystyle{humannat}
\bibliography{iclr2021}

\appendix

\section{Batch generation} \label{app-sec-bg}

We consider several empirical strategies for sub-sequence generation to compare with the random slices algorithm described in section "Sampling of surrogate sequences" of the main paper.
The simplest strategy is the random sampling without replacement.
One more strategy is to produce sub-sequences by random splitting of the initial sequence to several connected segments without intersection between them. To generate k sub-sequences, the following procedure should be repeated k times: take a random number of elements from the sequence \textit{without replacement}.

\begin{algorithm}
\SetAlgoLined
\textbf{hyperparameters:} $k$: number of sub-sequences to be produced. \\
\textbf{input:} A sequence $S$ of length $l$. \\
\textbf{output:} $S_1,...,S_k$: sub-sequences of $S$. \\

\BlankLine
Generate vector $inds$ of length $l$ with random integers from [1,k].\\
 \For{$i\leftarrow 1$ \KwTo $k$}{
 $S_i = S[inds == i]$
 }
\caption{Disjointed sub-sequences generation strategy}
\label{alg-disj-ss}

\end{algorithm}

\section{Performance optimizations} \label{app-sec-perf-opt}

Here we describe several performance optimizations that can be used for model training and inference.

\textbf{Pair distance calculation.} In order to select negative samples, we need to compute pair-wise distance between all possible pairs of embedding vectors of a batch. For the purpose of making this procedure more computationally effective we perform normalization of the embedding vectors, i.e. project them on a hyper-sphere of unit radius. Since $D(A,B) = \sqrt{\sum_i(A_i - B_i)^2} = \sqrt{\sum_i A_i^2 + \sum_i B_i^2 - 2\sum_i A_i B_i} $ and $||A||= ||B||=1$, to compute the euclidean distance we only need to compute: $\sqrt{2 - 2(A \cdot B)}$.

To compute the dot product between all pairs in a batch we just need to multiply the matrix of all embedding vectors of a batch by itself transposed, which is a highly optimized computational procedure in most modern deep learning frameworks. Hence, the computational complexity of the negative pair selection is $O(n^2h)$ where $h$ is the size of the output embeddings and $n$ is the size of the batch.

\textbf{Embedding update calculation.} Encoder, based on RNN-type architecture like GRU~\citep{Cho2014LearningPR}, allows to calculate embedding $c_{t+k}$ by updating embedding $c_t$ instead of  calculating embedding $c_{t+k}$ from the whole sequence of past events $z_{1:t}$: $c_k = rnn(c_t, z_{t+1:k})$. We use this optimization to reduce inference time to update already existing person embeddings with new events, occurred after the calculation of embeddings. This is possible due to the recurrent nature of RNN-like networks.

\section{Proof of Theorem 1} \label{app-sec-proof}

In this section, we provide the proof of Theorem 1 that justifies Random Slices sub-sequence generation strategy proposed in the paper. First, we give the statement of Theorem~1 for convenience.

Assume that process $\{X_e(t)\}_{t=1}^{T_e}$ is a segment of a latent process $\{\widehat{X}_e(t)\}_{t=1}^{\infty}$, which generates sequence of all events in the potentially infinite life of entity $e$. That is, we assume that $X_e(t)=\widehat{X}_e(t+s_e)$ for some random starting point $s_e\in \{0,1,\ldots\}$ and horizon $T_e$. Thus we observe, in our data, segment $[s_e+1,s_e+T_e]$ of the life of $e$. We also make the following Assumptions:
\begin{enumerate}
    \item Process $\{\widehat{X}_e(t)\}_{t=1}^{\infty}$ is cyclostationary (in the strict sense)~\citep{Gardner2006Cyclostationarity} with some period $\widehat{T}$.
    \item Starting $s_e$ is independent, and the distribution of $(s_e \mod \widehat{T})$ is uniform over $[0,\widehat{T}-1]$.
    \item Horizon $T_e$ is independent and follows a power--law distribution on $[m,\infty]$.
\end{enumerate}
\begin{thm}
If sequences $\{x_e(t)\}$ in the dataset are samples of processes $\{X_e(t)\}$, then sub-sequences obtained by the Random Slices generation strategy from $\{x_e(t)\}$ follow the same distribution as $\{x_e(t)\}$ up to a slight alteration of the distribution of the horizon $T_e$. Namely, if $T_e$ follows power law with an exponent $\alpha <-1$, then the density function for the length $T'_e$ of a sub-sequence satisfy 
\begin{equation}\label{probability_ratio}
\P(T'_e=k)/\P(T_e=k)\in \left [\left (\frac{m-1}{m}\right )^{-\alpha},\left (\frac{k}{k-1/2}\right )^{-\alpha}\right ].    
\end{equation}

\end{thm}

\begin{proof}
First, we state the following straightforward lemma:
\begin{lem}\label{stationary}
Let a stochastic process $\{Y(t)\}_{t=1}^{\infty}$ be a shift of another stochastic process $\{\widehat{Y}(t)\}_{t=1}^{\infty}$ by independent random time $s$, i.e. $Y(t) = \widehat{Y}(t+s)$ with integer $s\geq 0$. If process $\{\widehat{Y}(t)\}_{t=1}^{\infty}$ is cyclostationary with period $\widehat{T}$ and $(s_e \mod \widehat{T})$ is uniform over $[0,\widehat{T}-1]$, then process $\{Y(t)\}_{t=1}^{\infty}$ is stationary.
\end{lem}
Lemma~\ref{stationary} implies that process $\{X_e(t)\}_{t=1}^{T_e}$ is stationary, and all its segments $\{X_e(t)\}_{t=s'+1}^{T'_e+s'}$ of a given length $T'_e$ define the same distribution over sequences as its starting segment $\{X_e(t)\}_{t=1}^{T'_e}$ does. Furthermore, integrating over $s'$, we conclude that the conditional distribution of a sub-sequence obtained via Random Slices generation strategy given its length $T'_e$ follows the process $\{X_e(t)\}_{t=1}^{T'_e}$. To finish the proof, it remains to prove Equation~\ref{probability_ratio}.

Assume $\P(T_e=k)\propto k^{\alpha}$ for $k\in [m,\infty]$. By the law of total probability, we have $\P(T'_e=k_0)= \sum_{k}\P(T_e=k)\P(T'_e=k_0\mid T_e=k)$, that is,
$$
\P(T'_e=k_0) = C \sum_{k=k_0}^{\infty} k^{\alpha-1},
$$
where $C$ is the normalization constant. To estimate the sum of the series, notice that
\begin{equation}\label{int_inequal}
\int_{k_0-\frac{1}{2}}^\infty x^{\alpha-1} dx > \sum_{k=k_0}^{\infty} k^{\alpha-1} > \int_{k_0}^\infty x^{\alpha-1} dx,    
\end{equation}
where the former inequality follows from the fact that $\int_{k-1/2}^{k+1/2} x^{\alpha-1}> k^{\alpha-1}$ as long as function $f(x)=x^{\alpha-1}$ is convex. After integration, we rewrite Equation~\ref{int_inequal} as follows:
\begin{equation}\label{inequal}
\frac{-1}{\alpha} \left ( k_0-\frac{1}{2}\right )^{\alpha} > \sum_{k=k_0}^{\infty} k^{\alpha-1} > \frac{-1}{\alpha} k_0^{\alpha}. \end{equation}
Using these inequalities, we obtain the upper bound for $\P(T'_e=k)/\P(T_e=k)$ in the following way:
\begin{multline*}
\P(T'_e=k_0) = \sum_{k=k_0}^{\infty} k^{\alpha-1} / \sum_{l=m}^\infty \sum_{k=l}^{\infty} k^{\alpha-1} < \frac{-1}{\alpha} \left ( k_0-\frac{1}{2}\right )^{\alpha} / \sum_{l=m}^\infty \frac{-1}{\alpha} l^{\alpha} = \\
=\left (\frac{k_0}{k_0-1/2}\right )^{-\alpha} k_0^\alpha/\sum_{l=m}^\infty l^{\alpha} = \left (\frac{k_0}{k_0-1/2}\right )^{-\alpha} \P(T_e=k_0).
\end{multline*}
At last, the lower bound for $\P(T'_e=k)/\P(T_e=k)$ can be obtained using Equation~\ref{inequal} as follows:
\begin{multline*}
\P(T'_e=k_0) = \sum_{k=k_0}^{\infty} k^{\alpha-1} / \sum_{l=m}^\infty \sum_{k=l}^{\infty} k^{\alpha-1} > k_0^{\alpha} / \sum_{l=m}^\infty  \left (l-\frac{1}{2}\right )^{\alpha} > \\
> \left (\frac{m-1/2}{m}\right )^{-\alpha} k_0^\alpha/\sum_{l=m}^\infty l^{\alpha} = \left (\frac{m-1/2}{m}\right )^{-\alpha} \P(T_e=k_0).
\end{multline*}
The latter inequality in these calculations follows from the fact that $\left (\frac{l-\frac{1}{2}}{l}\right )^{\alpha}<\left (\frac{m-\frac{1}{2}}{m}\right )^{\alpha}$ for $l>m$.

\end{proof}

\section{Datasets} \label{app-sec-datasets}

We designed the method specially for the user behavior sequences~\citep{Ni2018PerceiveYU}. These sequences consist of discrete events per person in continuous time, for example,  behavior on websites, credit card transactions, etc. 

Considering credit card transactions, each transaction has a set of attributes, either categorical or numerical including the timestamp of the transaction. An example of the sequence of three transactions with their attributes is presented in Table \ref{tab-tr-data}.
Merchant type field represents the category of a merchant, such as "airline", "hotel", "restaurant", etc.

\begin{table}
\centering
\caption{Data structure for a single credit card}
\begin{tabular}{llllll}
\toprule
\textbf{Date} & \textbf{Time} & \textbf{Amount} & \textbf{Currency} & \textbf{Country} & \textbf{Merchant Type} \\
\midrule
Jun 21 & 16:40& 230 & EUR & France & Restaurant \\
Jun 21 & 20:15 & 5 & USD & US & Transportation \\
Jun 22 & 09:30 & 40 & USD & US & Household Appliance \\
\bottomrule
\end{tabular}
\label{tab-tr-data}
\end{table}

Another example of user behavior data is click-stream: the log of internet pages  visits. The example of a click-stream log of a single user is presented in Table \ref{tab-cs-data}.

\begin{table}
\centering
\caption{Click-stream structure for a single user}
\begin{tabular}{llll}
\toprule
\textbf{Time} & \textbf{Date} & \textbf{Domain} & \textbf{Referrer Domain} \\
\midrule
17:40 & Jun 21 & amazon.com & google.com \\
17:41 & Jun 21 & amazon.com & amazon.com \\
17:45 & Jun 21 & en.wikipedia.org & google.com \\
\bottomrule
\end{tabular}
\label{tab-cs-data}
\end{table}


In our research we chose several publicly available datasets from data science competitions.
\begin{enumerate}
    \item \textbf{Age group prediction competition}\footnote{https://onti.ai-academy.ru/competition} - the task is to predict the age group of a person. The group ratio is balanced in the dataset. The dataset consists of 44M anonymized transactions representing 50k persons with a target labeled for only 30k of them (27M out of 44M transactions), for the other 20k persons (17M out of 44M transactions) label is unknown. Each transaction includes date, type (for example, grocery store, clothes, gas station, children's goods, etc.) and amount. We use all available 44M transactions for contrastive learning, excluding 10\% - for the test part of the dataset, and  5\% for the contrastive learning validation.
        
    % \item \textbf{Gender prediction competition}\footnote{https://www.kaggle.com/c/python-and-analyze-data-final-project/} - the task is a classification problem of predicting a gender. The dataset consists of 6,8M anonymized card transactions representing 15k clients, where only 8,4k of them are labeled. Each transaction is characterized by date, type (for ex. "ATM cash deposit"), amount and Merchant Category Code (MCC).
    
    \item \textbf{Churn prediction competition}\footnote{https://boosters.pro/championship/rosbank1/}. The dataset of 1M anonymized card transactions representing 10K clients was used to predict a churn probability. 5k clients have labels (0.49M out of 1M transactions), 5.2k clients haven't labels (0.52M out of 1M transactions). Target is binary, almost balanced with proportions 0.55 and 0.45. Transactions of the same type and month are grouped and represented as a single pseudo-transaction, which amount is the sum of grouped transactions. Each transaction is characterized by date, type, amount and Merchant Category Code.
    
    \item \textbf{Assessment prediction competition}\footnote{https://www.kaggle.com/c/data-science-bowl-2019} - the task is to predict the in-game assessments results based on the history of children gameplay data. Target is one of 4 grades, with proportions 0.50, 0.24, 0.14, 0.12. The dataset consists of 12M gameplay events combined in 330k gameplays representing 18k children. Gameplays of the nearly all (17.7k) children (0.9M out of 12M gameplay events) are labelled, the gameplays of the remaining 312k children (11.6M out of 12M gameplay events) are not labelled. Each gameplay event is characterized by timestamp, event code, incremental counter of events within a game session, time since the start of the game session, etc.
    
    \item \textbf{Retail purchase history age group prediction}\footnote{https://ods.ai/competitions/x5-retailhero-uplift-modeling} - the task is to predict the age group of a client based on its retail purchase history. The group ratio is balanced in the dataset. The dataset consists of 45,8M retail purchases representing 400k clients. Only labeled data is used. Each purchase is characterized by time, product level, segment, amount, value, points received.

\end{enumerate}

As Figure~\ref{fig-seq-len} shows, the event sequence length distribution is close to power-law distribution for every considered dataset.

\begin{figure}
  \centering
  \caption{Event sequence length distribution}
  \includegraphics[width=\linewidth]{figures/all_scenario_events_per_client.pdf}
  \label{fig-seq-len}
\end{figure}

\section{Experiment setup} \label{app-sec-exp-setup}

For all methods, random search on 5-fold cross-validation over the train set is used for hyper-parameter selection. The hyper-parameters with the best out-of-fold performance on train set are then chosen. The final set of hyper-parameters used for CoLES is shown in Table \ref{tab-hyper}. The number of sub-sequences generated for each sequence was always 5 for each dataset.

\begin{table}
\centering
\caption{Hyper-parameters for CoLES training}
\begin{tabular}{llllllll}
\toprule
\textbf{Dataset} & \makecell[l]{\textbf{Output} \\ \textbf{size}} & \makecell[l]{\textbf{Learning} \\ \textbf{rate}} & \makecell[l]{\textbf{N samples} \\ \textbf{in batch}} & \makecell[l]{\textbf{N} \\ \textbf{epochs}} & \makecell[l]{\textbf{Min seq} \\ \textbf{length}} & \makecell[l]{\textbf{Max seq} \\ \textbf{length}} & \textbf{Encoder} \\
\midrule
\textbf{Age group} & 800 & 0.001 & 64 & 150 & 25 & 200 & GRU \\
% \textbf{Gender} & 1024 & 0.002 & 128 & 150 & 15 & 75 & GRU \\
\textbf{Churn} & 1024 & 0.004 & 128 & 60 & 15 & 150 & LSTM \\
\textbf{Assessment} & 100 & 0.002 & 256 & 100 & 100 & 500 & GRU \\
\textbf{Retail} & 800 & 0.002 & 256 & 30 & 30 & 180& GRU \\
\bottomrule
\end{tabular}
\label{tab-hyper}
\end{table}

\subsection{Hand-crafted features} \label{app-sec-hand}

Here we describe the details of producing hand-crafted features. All attributes of each transaction are either numerical (e. g. amount) or categorical (e.g. merchant type (MCC code), transaction type, etc.). 
For numerical type of attribute we apply aggregation functions, such as 'sum', 'mean', 'std', 'min', 'max', over all transactions per user. For example, if we apply 'sum' for the numerical field 'amount' we obtain a feature 'sum of all transaction amounts per user'. 
For categorical type of attribute we apply aggregation functions in a slightly different way. For each unique value of categorical attribute we apply aggregation functions, such as 'count', 'mean', 'std' over all transactions per user' numerical attribute. For example, if we apply 'mean' for the numerical attribute 'amount' grouped by categorical attribute 'mcc code' we obtain a feature 'mean amount of all transactions for each mcc code per user'. 
For example, for age prediction task we have one categorical attribute (small group) with 200 unique values, combining it with amount we can produce $200 * 3$ features ('group0 x amount x count',  'group1 x amount x count', ..., 'group199 x amount x count', 'group0 x amount x mean', ...). In total we use approx 605 features for this task. % For gender prediction task we have two categorical features: 'MCC code' with approx 200 unique values and 'tr type' with approx 100 unique values. So in total we use $200 * 3 + 100 * 3 + 5 = 905$ features.
Note, that hand-crafted features contain information about user spending profile but omit information about transactions temporal order.

\section{Results} \label{app-sec-res}

\subsection{Design choices observations} \label{app-sec-design}

We consider several contrastive learning losses that showed promising performance on different datasets~\citep{Kaya2019DeepML} and some classical variants: contrastive~loss~\citep{Hadsell2006DimensionalityRB}, binomial deviance loss~\citep{Yi2014DeepML}, triplet loss \citep{Hoffer2015DeepML}, histogram~loss~\citep{Ustinova2016LearningDE}, and margin~loss~\citep{Manmatha2017SamplingMI}. The results of comparison are shown in the Table~\ref{tab-loss-type}.

It is interesting to observe that even contrastive loss that can be considered as the basic variant of contrastive learning loss allows to get strong results on the downstream tasks (see Table \ref{tab-loss-type}). Our hypothesis is that an increase in the model performance on contrastive learning task does not always lead to an increase in performance on downstream tasks.

As shown in Table \ref{tab-enc-type}, different choices of encoder architectures show comparable performance on the downstream tasks.

\begin{table}
\centering
\caption{Comparison of encoder types}
\begin{tabular}{llll}
\toprule
\textbf{Dataset} & \textbf{LSTM} & \textbf{GRU} & \textbf{Transformer} \\
\midrule
\textbf{Age group} \small{(Accuracy)} & 0.621 $\pm 0.008$ & \textbf{0.638} $\pm 0.007$ & $0.622 \pm 0.006$ \\
% \textbf{Gender} \small{(AUROC)} & $0.857 \pm 0.009$ & \textbf{0.876} $\pm 0.007$ & $0.860 \pm 0.012$  \\
\textbf{Churn} \small{(AUROC)} & \textbf{0.823} $\pm 0.017$ & $0.812 \pm 0.010$ & $0.780 \pm 0.012$  \\
\textbf{Assessment} \small{(Accuracy)} & \textbf{0.620} $\pm 0.007$ & \textbf{0.618} $\pm 0.009$ & $0.542 \pm 0.007$  \\
\textbf{Retail} \small{(Accuracy)} & $0.535 \pm 0.003$ & \textbf{0.542} $\pm 0.002$ & $0.499 \pm 0.002$  \\
\bottomrule
\end{tabular} \\
\small{5-fold cross-validation metric $\pm 95\%$ is shown}
\label{tab-enc-type}
\end{table}

\begin{table}
\centering
\caption{Comparison of contrastive learning losses}
\begin{tabular}{llllll}
\toprule
\textbf{Dataset} & \makecell{\textbf{Contrastive} \\ (margin=0.5)} & \makecell{\textbf{Binomial} \\ \textbf{deviance}} & \textbf{Histogram} & \textbf{Margin} & \textbf{Triplet} \\
\midrule
\makecell{\textbf{Age group} \\ \small{(Accuracy)}} & \makecell{\textbf{0.639} \\ $\pm 0.006$} & \makecell{0.621 \\ $\pm 0.005$} & \makecell{0.632 \\ $\pm 0.008$} & \makecell{0.638 \\ $\pm 0.007$} & \makecell{0.636 \\ $\pm 0.004$} \\
% \makecell{\textbf{Gender} \\ \small{(AUROC)}} & \makecell{\textbf{0.876} \\ $\pm 0.007$} & \makecell{0.851 \\ $\pm 0.012$} & \makecell{0.859 \\ $\pm 0.007$} & \makecell{\textbf{0.875} \\ $\pm 0.008$} & \makecell{0.863 \\ $\pm 0.010$} \\
\makecell{\textbf{Churn} \\ \small{(AUROC)}} & \makecell{\textbf{0.823} \\ $\pm 0.017$} & \makecell{0.769 \\ $\pm 0.018$} & \makecell{0.815 \\ $\pm 0.018$} & \makecell{\textbf{0.823} \\ $\pm 0.012$} & \makecell{0.781 \\ $\pm 0.021$} \\
\makecell{\textbf{Assessment} \\ \small{(Accuracy)}} & \makecell{\textbf{0.618} \\ $\pm 0.009$} & \makecell{0.589 \\ $\pm 0.004$} & \makecell{0.615 \\ $\pm 0.007$} & \makecell{0.612 \\ $\pm 0.005$} & \makecell{0.600 \\ $\pm 0.004$} \\
\makecell{\textbf{Retail} \\ \small{(Accuracy)}} & \makecell{\textbf{0.542} \\ $\pm 0.002$} & \makecell{0.535 \\ $\pm 0.004$} & \makecell{0.533 \\ $\pm 0.002$} & \makecell{0.541 \\ $\pm 0.001$} & \makecell{0.541 \\ $\pm 0.001$} \\
\bottomrule
\end{tabular} \\
\small{5-fold cross-validation metric $\pm 95\%$ is shown}
\label{tab-loss-type}
\end{table}

\begin{table}
\centering
\caption{Comparison of negative sampling strategies}
\begin{tabular}{llll}
\toprule
\textbf{Dataset} & \makecell{\textbf{Hard negative} \\ \textbf{mining}} & \makecell{\textbf{Random negative} \\ \textbf{sampling}} & \makecell{\textbf{Distance weighted} \\ \textbf{sampling}} \\
\midrule
\makecell{\textbf{Age group} \small{(Accuracy)}} & \textbf{0.639} $\pm 0.006$ & $0.626 \pm 0.008$ & $0.629 \pm 0.004$ \\
% \makecell{\textbf{Gender} \small{(AUROC)}} & \textbf{0.876} $\pm 0.007$ & $0.842 \pm 0.015$ & $0.847 \pm 0.015$ \\
\makecell{\textbf{Churn} \small{(AUROC)}} & \textbf{0.823} $\pm 0.017$ & $0.815 \pm 0.013$ & $0.821 \pm 0.014$ \\
\makecell{\textbf{Assessment} \small{(Accuracy)}} & \textbf{0.618} $\pm 0.009$ & $0.593 \pm 0.002$ & $0.603 \pm 0.010$ \\
\makecell{\textbf{Retail} \small{(Accuracy)}} & \textbf{0.542} $\pm 0.002$ & $0.530 \pm 0.002$ & $0.536 \pm 0.002$ \\
\bottomrule
\end{tabular} \\
\small{5-fold cross-validation metric $\pm 95\%$ is shown}
\label{tab-neg-sampl}
\end{table}

\subsection{Embedding size}

Figure \ref{fig-emb-dim} shows that the performance quality on the downstream task increases with  dimensionality of an embedding. After the best quality is achieved, further increase in dimensionality of an embedding dramatically reduces quality.
These results can be interpreted as the bias-variance trade-off. When the embedding dimensionality is too small, too much information can be discarded (high bias). On the other hand, when embedding dimensionality is too large, too much noise is added (high variance).
Note, that increasing the embedding size will also linearly increase the training time and the volume of consumed memory on the GPU.

\begin{figure}
  \centering
  \caption{Embedding dimensionality vs. quality}
  \begin{subfigure}{0.5\linewidth}
    \caption{Age group}
    \includegraphics[width=\linewidth]{figures/hidden_size_age_pred.pdf}
  \end{subfigure}%
  \begin{subfigure}{0.5\linewidth}
    \caption{Churn}
    \includegraphics[width=\linewidth]{figures/hidden_size_rosbank.pdf}
  \end{subfigure}
  \begin{subfigure}{0.5\linewidth}
    \caption{Assessment}
    \includegraphics[width=\linewidth]{figures/hidden_size_bowl2019.pdf}
  \end{subfigure}%
  \begin{subfigure}{0.5\linewidth}
    \caption{Retail}
    \includegraphics[width=\linewidth]{figures/hidden_size_x5.pdf}
  \end{subfigure}
  \label{fig-emb-dim}
\end{figure}

\subsection{Semi-supervised setup} \label{app-sec-semi}

To evaluate our method in case of the restricted amount of labeled data, we use only part of the available target labels for the semi-supervised experiment, see Section~\ref{sec-res} for details. As in the case of the supervised setup, we compare the proposed method with LigthGBM over hand-crafted features, CPC, and supervised learning without pre-training. In figure \ref{fig-semi} we provide learning curves for all considered datasets.

\begin{figure}
  \centering
  \begin{subfigure}{0.5\linewidth}
    \caption{Age group}
    \includegraphics[width=\linewidth]{figures/ss_age_pred_per.pdf}
    \label{fig-semi-age2}
  \end{subfigure}%
  \begin{subfigure}{0.5\linewidth}
    \caption{Churn}
    \includegraphics[width=\linewidth]{figures/ss_rosbank_per.pdf}
    \label{fig-semi-churn}
  \end{subfigure}
  \begin{subfigure}{0.5\linewidth}
    \caption{Assessment}
    \includegraphics[width=\linewidth]{figures/ss_bowl2019_per.pdf}
    \label{fig-semi-assessment2}
  \end{subfigure}%
  \begin{subfigure}{0.5\linewidth}
    \caption{Retail}
    \includegraphics[width=\linewidth]{figures/ss_x5_per.pdf}
    \label{fig-semi-retail}
  \end{subfigure}
  \caption{Model quality for different dataset sizes} \small{The rightmost point corresponds to all labels and supervised setup.}
  \label{fig-semi}
\end{figure}

\subsection{Embedding visualization} \label{app-sec-vis}

In order to visualize CoLES embeddings in 2-dimensional space, we applied tSNE transformation~\citep{Maaten2008VisualizingDU} on them. tSNE transforms high-dimensional space to low-dimensional based on local relationships between points, so neighbour vectors in high-dimensional embedding space are pushed to be close in 2-dimensional space. We colorized 2-dimensional vectors using the target values of the datasets.

Note, that embeddings was learned in a fully self-supervised way from raw user transactions without any target information. Sequence of transactions represent user' behavior, thus the CoLES model captures behavioral patterns and outputs embeddings of users with similar patterns nearby.
As shown below, local clusters in embedding space correspond to distribution of user's attributes either age or churn fact.

tSNE vectors from the age prediction dataset are presented in the Figure \ref{fig-tsne-age2}. We can observe 4 clusters: clusters for group '1' and '2' are on the opposite side of the cloud, clusters for groups '2' and '3' are in the middle.

Taking into account that age is an ordinal attribute, we can make an assumption about the ordering of age groups: $age(1) < age(3) < age(0) < age(2)$ or vice versa. ($age(bin)$ returns age of user for specific group).

tSNE points from the churn prediction dataset are presented in the Figure \ref{fig-tsne-churn}. There are areas where one type of label dominates over the other.

\begin{figure}
  \centering
  \caption{2D tSNE mapping of CoLES embeddings colored by target labels}
  \begin{subfigure}{0.5\textwidth}
    \caption{Age group}
    \includegraphics[width=\textwidth]{figures/iclr-age-pred-tsne.pdf}
    \label{fig-tsne-age2}
  \end{subfigure}%
  \begin{subfigure}{0.5\textwidth}
    \caption{Churn}
    \includegraphics[width=\textwidth]{figures/iclr-churn-tsne.pdf}
    \label{fig-tsne-churn}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \caption{Assessment}
    \includegraphics[width=\textwidth]{figures/iclr-bowl-tsne-accuracy_group.pdf}
    \label{fig-tsne-bowl}
  \end{subfigure}%
  \begin{subfigure}{0.5\textwidth}
    \caption{Retail}
    \includegraphics[width=\textwidth]{figures/iclr-x5-tsne-age_bin.pdf}
    \label{fig-tsne-x5}
  \end{subfigure}
\end{figure}

\end{document}
